<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Final Parsec</title><link href="/" rel="alternate"></link><link href="/feeds%5Cmatt.atom.xml" rel="self"></link><id>/</id><updated>2015-04-20T00:00:00-05:00</updated><entry><title>Enemy Health and Explosions</title><link href="/legacy-earth-enemy-health-and-explosions.html" rel="alternate"></link><updated>2015-04-20T00:00:00-05:00</updated><author><name>Matt</name></author><id>tag:,2015-04-20:legacy-earth-enemy-health-and-explosions.html</id><summary type="html">&lt;p&gt;This is a continuation of Final Parsec's tutorial series on building a space-themed rail shooter with Unity3d.
In previous tutorials, we've discussed enemies detecting and firing at the player.
Now we have come to the point where the player needs to be able to fight back.&lt;/p&gt;
&lt;p&gt;In this video tutorial, I'll discuss managing the health of enemies when they get shot by the player.
Then we'll discuss how to make the enemies blow up and be removed from the game when they are dead.&lt;/p&gt;
&lt;p&gt;You can follow along with the development of the project and find the source code from the tutorial on &lt;a href="https://github.com/Final-Parsec/Blueshift"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/1gTJWuKe6po?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;</summary><category term="snakes"></category><category term="alpha"></category><category term="legacy-earth"></category><category term="tutorial"></category><category term="legacy-earth-video-series"></category><category term="unity"></category></entry><entry><title>Turrets and Missiles Tutorial</title><link href="/legacy-earth-turrets-and-missiles.html" rel="alternate"></link><updated>2015-02-28T00:00:00-06:00</updated><author><name>Matt</name></author><id>tag:,2015-02-28:legacy-earth-turrets-and-missiles.html</id><summary type="html">&lt;p&gt;This is a continuation of Final Parsec's tutorial series on building a space-themed rail shooter with Unity3d.
Combat in this game involves dodging fire from ground based turrets.&lt;/p&gt;
&lt;p&gt;In this tutorial, I'll be going over how to build turrets which detect the player using colliders.
Then we'll discuss how to make the turret face the player and fire.&lt;/p&gt;
&lt;p&gt;You can follow along with the development of the project and find the source code from the tutorial on &lt;a href="https://github.com/Final-Parsec/Blueshift"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/zgqh98HZI3E?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;</summary><category term="snakes"></category><category term="alpha"></category><category term="legacy-earth"></category><category term="turret"></category><category term="tutorial"></category><category term="legacy-earth-video-series"></category><category term="unity"></category></entry><entry><title>Ship Movement Tutorial</title><link href="/legacy-earth-ship-movement.html" rel="alternate"></link><updated>2015-02-15T00:00:00-06:00</updated><author><name>Matt</name></author><id>tag:,2015-02-15:legacy-earth-ship-movement.html</id><summary type="html">&lt;p&gt;Our new game is going to be a space rail shooter. 
Similar to the Star Fox series, we plan on creating an immersive story with a simple user interface.
The enemies will be ground turrets and flying types with multiple engagement modes.
There will also be unique boss battles at the end of most of the levels.&lt;/p&gt;
&lt;p&gt;In this tutorial I'll be going over the ship and camera movement.&lt;/p&gt;
&lt;p&gt;We have our up to date source code and project files on &lt;a href="https://github.com/Final-Parsec/Blueshift"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/TKF7d1BVE0Q?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;</summary><category term="snakes"></category><category term="alpha"></category><category term="legacy-earth"></category><category term="movement"></category><category term="tutorial"></category><category term="legacy-earth-video-series"></category><category term="unity"></category></entry><entry><title>A* Pathfinding Visualization</title><link href="/a-star-visualization.html" rel="alternate"></link><updated>2015-01-13T00:00:00-06:00</updated><author><name>Matt</name></author><id>tag:,2015-01-13:a-star-visualization.html</id><summary type="html">&lt;p&gt;Here is a small program that I made for a parallel class project during my first semester of graduate school. At the end of the class project, I decided to continue work on it in order to improve path quality, be more user friendly, and introduce a tracing option.&lt;/p&gt;
&lt;p&gt;The program visualizes Sequential A* and Parallel New Bidirectional A* (PNBA*).&lt;br&gt;
The biggest achievement of this program is the implementation of the PNBA* algorithm as described in &lt;a href="http://homepages.dcc.ufmg.br/~chaimo/public/ENIA11.pdf"&gt;PNBA*: A Parallel Bidirectional Heuristic Search Algorithm&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="/category/unity-masters.html"&gt;See the live demo in your browser here!&lt;/a&gt;&lt;/p&gt;
&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/kln3dZ9WcCg?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/CgUIVrIIaPY?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/Gf6W26AQG-o?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;</summary><category term="unity"></category><category term="unity-masters"></category><category term="map-generation"></category><category term="pathfinding"></category><category term="tutorial"></category></entry><entry><title>Tower Defense Tutorials Part 6: In Game Menu and All the Little Things</title><link href="/tower-defense-in-game-menu-and-little-things.html" rel="alternate"></link><updated>2014-12-07T00:00:00-06:00</updated><author><name>Matt</name></author><id>tag:,2014-12-07:tower-defense-in-game-menu-and-little-things.html</id><summary type="html">&lt;p&gt;
    This video demonstrates how to build an in game options menu.
    I provide a discussion on the usage of NGUI and future changes to building user interfaces in upcoming versions of Unity.
&lt;/p&gt;

&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/GHbWHnSYvow?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;
    We also showcase some of the enhancements we've made since previous videos: turret upgrades, special effects, and environment changes.
&lt;/p&gt;</summary><category term="tower-defense"></category><category term="unity"></category><category term="tutorial"></category><category term="td-video-series"></category></entry><entry><title>Tower Defense Tutorials Part 5: Passing Data and Menus</title><link href="/tower-defense-passing-data-and-menus.html" rel="alternate"></link><updated>2014-11-30T00:00:00-06:00</updated><author><name>Matt</name></author><id>tag:,2014-11-30:tower-defense-passing-data-and-menus.html</id><summary type="html">&lt;p&gt;
    This tutorial goes over how to pass data between scenes using the singleton pattern, something especially useful when a user is picking map types and difficulty in a separate menu scene.
    We also give an overview of building a menu system with Prezi-style transitions (panning and zooming camera with parallax effects).
&lt;/p&gt;

&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/KYADPkNTEHM?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;
    In addition to building the menu and passing state data around, learn how to display a loading screen between scenes.
    Without this, the game may appear to hang when a player starts from the main menu.
&lt;/p&gt;</summary><category term="tower-defense"></category><category term="unity"></category><category term="tutorial"></category><category term="td-video-series"></category></entry><entry><title>Tower Defense Tutorials Part 4: Creating Waves of Enemies</title><link href="/tower-defense-creating-waves-of-enemies.html" rel="alternate"></link><updated>2014-11-25T00:00:00-06:00</updated><author><name>Matt</name></author><id>tag:,2014-11-25:tower-defense-creating-waves-of-enemies.html</id><summary type="html">&lt;p&gt;
    This tutorial goes over how to create random waves of enemies.
    The waves include bosses every 10th wave and different types of enemies. 
    Waves are sent either when an interval of time has passed or the player has commanded a new wave. 
    Also, multiple waves can be actively spawning enemies at the same time.
&lt;/p&gt;

&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/2FZ30gX8Drs?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;</summary><category term="tower-defense"></category><category term="unity"></category><category term="tutorial"></category><category term="td-video-series"></category></entry><entry><title>Tower Defense Tutorials Part 3: Enemies and Pathfinding</title><link href="/tower-defense-moving-enemies-and-pathfinding.html" rel="alternate"></link><updated>2014-10-12T00:00:00-05:00</updated><author><name>Matt</name></author><id>tag:,2014-10-12:tower-defense-moving-enemies-and-pathfinding.html</id><summary type="html">&lt;p&gt;
    If you've been following along with our &lt;a href="/tag/td-video-series.html"&gt;video tutorial series&lt;/a&gt;, your game should now have a map with the basic interaction of placing turrets.
    To get the core functionality of our game, we will be needing enemies to move across the map.
    They will also need to navigate around turrets on the way to their destination.
&lt;/p&gt;

&lt;p&gt;
    This tutorial goes over how to move enemies on the grid we have created and how to use A* pathfinding to avoid obstacles.
    Pathfinding of this nature is something we have already implemented in a previous game (&lt;a href="/category/nauticus.html"&gt;Nauticus Act III&lt;/a&gt;), so we're just going to reuse the component.
    If you are actually looking to implement pathfinding from scratch, we cover this in depth in a &lt;a href="/a-star-pathfinding-tutorial.html"&gt;previous tutorial&lt;/a&gt;.
&lt;/p&gt;

&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/Q7ef6wLDfrE?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;
    With enemies, we now really have the essence of a tower defense game in place.
    There are some obvious next steps here however... turrets still aren't attacking and having a single enemy doesn't make for a very interesting game.
    Our upcoming tutorials will show how to address these challenges.
&lt;/p&gt;

&lt;p&gt;
    You can keep up with the latest as we progress by subscribing to our channel or following us on twitter.  
    &lt;a href="https://www.youtube.com/channel/UCHcxGunEdEPlgq5JulJ2fYQ"&gt;&lt;img src="/theme/images/icons/youtube.png" /&gt;&lt;/a&gt;
    &lt;a href="https://twitter.com/Final_Parsec"&gt;&lt;img src="/theme/images/icons/twitter.png" /&gt;&lt;/a&gt;    
&lt;/p&gt;</summary><category term="tower-defense"></category><category term="unity"></category><category term="tutorial"></category><category term="pathfinding"></category><category term="td-video-series"></category></entry><entry><title>Tower Defense Tutorials Part 2: Interfacing with the Map</title><link href="/tower-defense-interfacing-with-the-map.html" rel="alternate"></link><updated>2014-10-02T00:00:00-05:00</updated><author><name>Matt</name></author><id>tag:,2014-10-02:tower-defense-interfacing-with-the-map.html</id><summary type="html">&lt;p&gt;
    So now that you have a grid environment similar to what we built in the &lt;a href="/tower-defense-no-gameobject-grid.html"&gt;previous tutorial&lt;/a&gt;, it's time to actually start using it.
    This tutorial goes over how the user interfaces and interacts with the map.
&lt;/p&gt;

&lt;p&gt;
    At this point, the primary interaction with the map will be handling a player's clicks and placing turrets for them.
    It is necessary to ensure the turrets are placed at valid locations, and also to update the paths of enemies as the world changes around them.
    In this tutorial, we dig into placing turrets on the map. 
&lt;/p&gt;

&lt;p&gt;
    Upcoming tutorials cover getting enemies to move around and making the turrets attack, so be sure to check back!
&lt;/p&gt;

&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/rUhcdcS6mj4?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;</summary><category term="tower-defense"></category><category term="unity"></category><category term="tutorial"></category><category term="map-generation"></category><category term="td-video-series"></category></entry><entry><title>Announcing the Tower Defense Tutorial Video Series!</title><link href="/tower-defense-no-gameobject-grid.html" rel="alternate"></link><updated>2014-09-28T00:00:00-05:00</updated><author><name>Matt</name></author><id>tag:,2014-09-28:tower-defense-no-gameobject-grid.html</id><summary type="html">&lt;p&gt;
    Over the next couple months, Final Parsec will be creating a tower defense style game.
    Follow along as we build from the ground up to a game intended for the web and Android devices.
&lt;/p&gt;

&lt;h3&gt;Building a Grid Environment without GameObjects&lt;/h3&gt;

&lt;p&gt;
    This tutorial will demonstrate how to create a grid without using Unity GameObjects.
    By eliminating the overhead of multiple GameObjects, we can increase performance.
    The grid we're building here will be a vital piece of infrastructure as enemies will walk across it, turrets will be placed on it, and it will handle user interaction in various ways.
&lt;/p&gt;

&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/auCv_U7Wd8Y?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;</summary><category term="tower-defense"></category><category term="unity"></category><category term="tutorial"></category><category term="map-generation"></category><category term="td-video-series"></category></entry><entry><title>Creating Health Bars using Unity GUI Textures</title><link href="/unity-health-bars-with-gui-textures.html" rel="alternate"></link><updated>2014-09-14T00:00:00-05:00</updated><author><name>Matt</name></author><id>tag:,2014-09-14:unity-health-bars-with-gui-textures.html</id><summary type="html">&lt;p&gt;In this tutorial, I take you through the steps to create health bars in Unity. They scale in size based on the camera's position, and they will also change color from green to red. &lt;/p&gt;
&lt;p&gt;We will build them using Unity's GUI textures which are ideal for this type of application. While we're applying them in an RTS style game with an overhead camera, you should be able to implement something similar in your game no matter the genre.&lt;/p&gt;
&lt;p&gt;If you have any questions about this tutorial or others I have posted, leave us a comment on the Youtube video.&lt;/p&gt;
&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/qJ_NgSdkfQ0?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;</summary><category term="nauticus"></category><category term="tutorial"></category><category term="unity"></category></entry><entry><title>Unity Animator State Machine Tutorial</title><link href="/unity-animator-state-machine-tutorial.html" rel="alternate"></link><updated>2014-08-17T00:00:00-05:00</updated><author><name>Matt</name></author><id>tag:,2014-08-17:unity-animator-state-machine-tutorial.html</id><summary type="html">&lt;p&gt;I was having trouble finding examples on the internet on how to create complex animator state machines using Unity, so I came up with my own solution and made a tutorial on how I implemented it.&lt;/p&gt;
&lt;p&gt;If you have any questions about this issue or others I have posted, leave us a comment on the Youtube video or check out our Sunday afternoon podcasts at &lt;a href="http://twitch.tv/finalparsec"&gt;twitch.tv/finalparsec&lt;/a&gt;.&lt;/p&gt;
&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/xPw9bknBOwI?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;</summary><category term="nauticus"></category><category term="tutorial"></category><category term="unity"></category></entry><entry><title>A* Pathfinding Tutorial</title><link href="/a-star-pathfinding-tutorial.html" rel="alternate"></link><updated>2014-08-03T00:00:00-05:00</updated><author><name>Matt</name></author><id>tag:,2014-08-03:a-star-pathfinding-tutorial.html</id><summary type="html">&lt;p&gt;Pathfinding plays a vital part of Nauticus Act III.
This technical tutorial demonstrates implementing and optimizing A-Star path finding in a Unity3D game.&lt;/p&gt;
&lt;p&gt;Code from our project:
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://docs.google.com/file/d/0B-JImkXz82YGdjZpb0U3aXNubTA"&gt;EventHandler.cs&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://docs.google.com/file/d/0B-JImkXz82YGbTVtMTM4a214aXc"&gt;MinHeap.cs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
&lt;div class="video-container"&gt;
    &lt;iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/Lv9LyAwxGXY?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;And some additional resources to help get you started:
&lt;ul&gt;
    &lt;li&gt;&lt;a href="http://www.policyalmanac.org/games/aStarTutorial.htm"&gt;A* Pathfinding for Beginners&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html"&gt;Introduction to A*&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/A*_search_algorithm"&gt;A* Search Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;</summary><category term="nauticus"></category><category term="alpha"></category><category term="tutorial"></category><category term="unity"></category><category term="pathfinding"></category></entry><entry><title>Using Cellular Automata to Create a Random Map Generator</title><link href="/nauticus-map-generation.html" rel="alternate"></link><updated>2014-03-31T00:00:00-05:00</updated><author><name>Matt</name></author><id>tag:,2014-03-31:nauticus-map-generation.html</id><summary type="html">&lt;h2&gt;Introduction to Cellular Automata&lt;/h2&gt;

&lt;p&gt;A cellular automaton consists of a grid of cells, each in one of a finite number of states, such as on and off. The grid can be in any finite number of dimensions. For each cell, a set of cells called its neighborhood is defined relative to the specified cell. An initial state is selected by assigning a state for each cell. A new generation is created, according to some fixed rule that determines the new state of each cell in terms of the current state of the cell and the states of the cells in its neighborhood. &lt;/p&gt;

&lt;h2&gt;The Game of Life&lt;/h2&gt;

&lt;p&gt;In the classic model of Cellular Automata (CA) Conway’s Game of Life, the cells follow four simple rules. &lt;p&gt;

&lt;ol&gt;
    &lt;li&gt;Any live cell with fewer than two live neighbors dies, as if caused by under-population.&lt;/li&gt;
    &lt;li&gt;Any live cell with two or three live neighbors lives on to the next generation.&lt;/li&gt;
    &lt;li&gt;Any live cell with more than three live neighbors dies, as if by overcrowding.&lt;/li&gt;
    &lt;i&gt;Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These simple rules ended up evolving complex patterns capable of motion and self-replication.So, if we take the ideas from this and apply them to map generation we should be able to create unique worlds for players to explore.&lt;/p&gt;

&lt;h2&gt;Applying CA to Map Generation&lt;/h2&gt;

&lt;p&gt;In Conway’s Game of Life the cell is either alive or dead and always stays in one location (Although patterns can give the appearance of motion). For map generation we are going to create agents to move fromtheir current cell to one of the neighboring cells.&lt;/p&gt;

&lt;h3&gt;Creating Agents&lt;/h3&gt;

&lt;p&gt;Agents work with a given set of rules. The rules of an agent are determined by what you want that agent to accomplish. Maybe you want an agent that can create meandering rivers, lakes, or mountain ranges. Rules can be developed to create all of these things. For this example we are only going to create on set of rules for all of our tile types.&lt;/p&gt;

&lt;p&gt;We want our agents to create groupings of tiles that are the same, while still having an element of randomness. To accomplish this we have 2 simple rules.&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;An agent can only move to a neighboring tile that is not the same type that the agent is creating.&lt;/li&gt;
    &lt;li&gt;An agent is more likely to move to a tile if that tile has more neighboring tiles of the agent’s type.&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Initial State&lt;/h3&gt;

&lt;p&gt;Initially I fill my map with one tile type, grass. Then I create a random number of Tree Agents, Mountain Agents, and Water Agents and place them randomly on the map.&lt;/p&gt;

&lt;p&gt;Each agent is given a number of times they are allowed to move. When they run out of moves or they can’t find a new place to move to, they are killed. The maps that are created can be varied by changing the number of agents that are used or by changing the number of times they are allowed to move. I start by filling a percentage of the map with agents and then give them a random number from a range to determine how far they can move.&lt;/p&gt;

&lt;h3&gt;Examples&lt;/h3&gt;

&lt;p&gt;Here are two example maps that my agents created. The larger map is 200x200 and the smaller map is 50x50.&lt;/p&gt;

&lt;img src="/theme/images/random_map_generation_1.png" style="width: 95%;" /&gt;

&lt;img src="/theme/images/random_map_generation_2.png" style="width: 95%;" /&gt;

&lt;p&gt;
&lt;strong&gt;Cell&lt;/strong&gt; A cell is a location inside the Map that contains a cell type that is manipulated by an agent.&lt;br&gt;&lt;br&gt;
&lt;strong&gt;Cell Type&lt;/strong&gt; The type of cell it is. Our cells have the following types Grass, Mountain, Water, and Tree.&lt;br&gt;&lt;br&gt;
&lt;strong&gt;Map&lt;/strong&gt; The map is a 2-demensinal plane that is separated into an NxM matrix of cells.&lt;br&gt;&lt;br&gt;
&lt;strong&gt;Neighborhood/Neighbors&lt;/strong&gt; The neighborhood of a cell consists of any cell that is touching or diagonal to the current cell.&lt;br&gt;&lt;br&gt;</summary><category term="nauticus"></category><category term="map-generation"></category></entry></feed>